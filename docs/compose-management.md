# Compose-Based VM Management

## Minimal Setup

```yaml
services:
  vm:
    image: ghcr.io/munenick/docker-vm-runner:latest
    devices:
      - /dev/kvm:/dev/kvm
    volumes:
      - vm-data:/data
    ports:
      - "2222:2222"
    stdin_open: true
    tty: true

volumes:
  vm-data:
```

```bash
docker compose up
```

See `docker-compose.minimal.yml` in the repository root for a ready-to-use version.

## Multi-VM Layout

The example below runs two VMs with named Docker volumes. Mounting a volume at `/data` automatically enables persistence — no need to set `PERSIST=1` or `DATA_DIR` explicitly. Redfish is enabled on the second VM to expose power-control APIs.

```yaml
services:
  vm1:
    image: ghcr.io/munenick/docker-vm-runner:latest
    container_name: vm1
    stdin_open: true
    tty: true
    devices:
      - /dev/kvm:/dev/kvm
    volumes:
      - vm1-data:/data
    environment:
      DISTRO: ubuntu-2404
      GUEST_NAME: vm1
      SSH_PORT: 2222
    ports:
      - "2222:2222"
      - "5900:5900"   # optional VNC
      - "6080:6080"   # optional noVNC

  vm2:
    image: ghcr.io/munenick/docker-vm-runner:latest
    container_name: vm2
    stdin_open: true
    tty: true
    devices:
      - /dev/kvm:/dev/kvm
    volumes:
      - vm2-data:/data
    environment:
      DISTRO: debian-12
      GUEST_NAME: vm2
      SSH_PORT: 2223
      REDFISH_ENABLE: 1
      REDFISH_PORT: 8444
    ports:
      - "2223:2223"
      - "8444:8444"   # Redfish

volumes:
  vm1-data:
  vm2-data:
```

*Tips*

- Each VM gets its own named volume at `/data`. Cloud images, work disks, and state are all stored inside the volume automatically. Mount `distros.yaml` if you want to override the built-in distribution list (`./distros.yaml:/config/distros.yaml:ro`).
- Avoid port collisions by choosing distinct `SSH_PORT`, `VNC_PORT`, `NOVNC_PORT`, and (if enabled) `REDFISH_PORT`.
- Redfish endpoints provide power and boot control: `curl -k https://localhost:8444/redfish/v1/Systems/vm2` or use any Redfish client with the configured credentials.

## Direct Networking with macvtap

Compose can also keep VMs attached to a macvtap NIC for bridged, upstream-visible addresses. This requires sharing the host network namespace and `/dev`, because libvirt creates `/dev/tap*` devices dynamically.

```yaml
services:
  vm-direct:
    image: ghcr.io/munenick/docker-vm-runner:latest
    container_name: vm-direct
    privileged: true
    network_mode: host
    volumes:
      - /dev:/dev
      - vm-direct-data:/data
    devices:
      - /dev/kvm:/dev/kvm
    environment:
      DISTRO: ubuntu-2404
      GUEST_NAME: vm-direct
      NETWORK_MODE: direct
      NETWORK_DIRECT_DEV: enp88s0      # replace with a real host NIC
      NETWORK_MAC: 52:54:00:aa:bb:cc   # optional, overrides the autogenerated MAC

volumes:
  vm-direct-data:
```

The guest will obtain an address from the upstream network (typically via DHCP). Once the VM is reachable, configure a static address inside the guest OS using netplan, NetworkManager, or equivalent tooling; the `/data` volume ensures those changes survive reboots.

## Operating the fleet

- Start every VM defined in the file: `docker compose up -d`
- Inspect status: `docker compose ps`
- View logs: `docker compose logs -f vm2`
- Reboot a single VM: `docker compose restart vm1`
- Shut down and retain disks: `docker compose stop`
- Destroy a VM (removes its libvirt domain; disks remain in the volume): `docker compose rm vm2`

Compose keeps the desired state in one YAML file, making it straightforward to reproduce lab environments or CI test beds that require multiple VMs with consistent networking and storage.

## Accessing Running VMs

- SSH via forwarded ports: `ssh -p 2222 <user>@localhost` (replace the port per service).
- Attach to the container’s serial console: `docker attach vm1` or `docker compose exec vm1 virsh console vm1`.
- Detach from a console session with `Ctrl+]`.
- Inspect guest state without leaving Compose: `docker compose exec vm2 virsh list`, `docker compose logs -f vm1`, etc.
