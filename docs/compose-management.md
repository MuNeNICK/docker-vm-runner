# Compose-Based VM Management

Docker Compose can act as a declarative VM manager: each service corresponds to one guest. Keep the desired state in `docker-compose.yml` and let `docker compose up` create or resume the machines, while `docker compose stop` gracefully shuts them down.

## Persistent Multi-VM Layout

The example below runs two VMs with dedicated storage trees. Each VM keeps its working disk because `PERSIST=1`. Redfish is enabled on the second VM to expose power-control APIs.

```yaml
version: "3.9"

services:
  vm1:
    image: ghcr.io/munenick/docker-vm-runner:latest
    container_name: vm1
    devices:
      - /dev/kvm:/dev/kvm
    volumes:
      - ./images/base:/images/base
      - ./images/vm1:/images/vms/vm1
      - ./images/state/vm1:/var/lib/docker-vm-runner
    environment:
      DISTRO: ubuntu-2404
      GUEST_NAME: vm1
      SSH_PORT: 2222
      PERSIST: 1
    ports:
      - "2222:2222"
      - "5900:5900"   # optional VNC
      - "6080:6080"   # optional noVNC

  vm2:
    image: ghcr.io/munenick/docker-vm-runner:latest
    container_name: vm2
    devices:
      - /dev/kvm:/dev/kvm
    volumes:
      - ./images/base:/images/base
      - ./images/vm2:/images/vms/vm2
      - ./images/state/vm2:/var/lib/docker-vm-runner
    environment:
      DISTRO: debian-12
      GUEST_NAME: vm2
      SSH_PORT: 2223
      PERSIST: 1
      REDFISH_ENABLE: 1
      REDFISH_PORT: 8444
    ports:
      - "2223:2223"
      - "8444:8444"   # Redfish
```

*Tips*

- Reuse `./images/base` to share cached cloud images across services, mount each persistent disk at `/images/vms/<guest>` (e.g., `./images/vm1:/images/vms/vm1`), and dedicate a state directory per VM (e.g., `./images/state/vm1:/var/lib/docker-vm-runner`).
- Avoid port collisions by choosing distinct `SSH_PORT`, `VNC_PORT`, `NOVNC_PORT`, and (if enabled) `REDFISH_PORT`.
- Redfish endpoints provide power and boot control: `curl -k https://localhost:8444/redfish/v1/Systems/vm2` or use any Redfish client with the configured credentials.

## Direct Networking with macvtap

Compose can also keep VMs attached to a macvtap NIC for bridged, upstream-visible addresses. This requires sharing the host network namespace and `/dev`, because libvirt creates `/dev/tap*` devices dynamically.

```yaml
services:
  vm-direct:
    image: ghcr.io/munenick/docker-vm-runner:latest
    container_name: vm-direct
    privileged: true
    network_mode: host
    volumes:
      - /dev:/dev
      - ./images/base:/images/base
      - ./images/vm-direct:/images/vms/vm-direct
      - ./images/state/vm-direct:/var/lib/docker-vm-runner
    devices:
      - /dev/kvm:/dev/kvm
    environment:
      DISTRO: ubuntu-2404
      GUEST_NAME: vm-direct
      NETWORK_MODE: direct
      NETWORK_DIRECT_DEV: enp88s0      # replace with a real host NIC
      NETWORK_MAC: 52:54:00:aa:bb:cc   # optional, overrides the autogenerated MAC
      PERSIST: 1
```

The guest will obtain an address from the upstream network (typically via DHCP). Once the VM is reachable, configure a static address inside the guest OS using netplan, NetworkManager, or equivalent tooling; `PERSIST=1` ensures those changes survive reboots. If you prefer cloud-init, edit `/images/vm-direct/cloud-init/user-data` after the first boot and reboot the VM.

## Operating the fleet

- Start every VM defined in the file: `docker compose up -d`
- Inspect status: `docker compose ps`
- View logs: `docker compose logs -f vm2`
- Reboot a single VM: `docker compose restart vm1`
- Shut down and retain disks: `docker compose stop`
- Destroy a VM (removes its libvirt domain; disks remain while `PERSIST=1`): `docker compose rm vm2`

Compose keeps the desired state in one YAML file, making it straightforward to reproduce lab environments or CI test beds that require multiple VMs with consistent networking and storage.

## Accessing Running VMs

- SSH via forwarded ports: `ssh -p 2222 <user>@localhost` (replace the port per service).
- Attach to the containerâ€™s serial console: `docker attach vm1` or `docker compose exec vm1 virsh console vm1`.
- Detach from a console session with `Ctrl+]`.
- Inspect guest state without leaving Compose: `docker compose exec vm2 virsh list`, `docker compose logs -f vm1`, etc.
